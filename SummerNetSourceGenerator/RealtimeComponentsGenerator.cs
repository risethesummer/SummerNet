using System;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SummerNetSourceGenerator;

[Generator]
public class RealtimeComponentsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider =
            context.CompilationProvider.Combine(
                context.SyntaxProvider
                    .CreateSyntaxProvider(
                        CheckGenericDataClass,
                        GetGenericData
                    )
                    .Where(t => t is not null)
                    .Collect()
            );
 
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private struct GenericTypesInData
    {
        public (INamedTypeSymbol type, string displayName) TPlayerIndex;
        public (INamedTypeSymbol type, string displayName) TAuthData;
        public (INamedTypeSymbol type, string displayName) TPlayer;
        public (INamedTypeSymbol type, string displayName) MatchData;
        public string PlayerGenericArguments { get; private set; }
        public string MatchGenericArguments { get; private set; }
        public void Init()
        {
            PlayerGenericArguments = $"{TPlayerIndex.displayName}, {TAuthData.displayName}, {TPlayer.displayName}";
            MatchGenericArguments = $"{MatchData.displayName}, {TPlayerIndex.displayName}, {TAuthData.displayName}, {TPlayer.displayName}";
        }
    }
    private static bool CheckGenericDataClass(SyntaxNode syntaxNode, CancellationToken _)
    {
        return syntaxNode is ClassDeclarationSyntax;
    }
    private static GenericTypesInData? GetGenericData(GeneratorSyntaxContext ctx, CancellationToken _)
    {
        var symbol = ctx.GetNamedTypeSymbol();
        var genericMatchSymbol = symbol?.InheritClass(
            GeneratorUtilities.Realtime.Data.MatchData, 
            GeneratorUtilities.Realtime.Data.MatchDataGenericCount);
        if (genericMatchSymbol is null)
            return null;
        var typeParams = genericMatchSymbol.TypeArguments;
        var playerIndex = typeParams[0] as INamedTypeSymbol;
        var authData = typeParams[1] as INamedTypeSymbol;
        var player = typeParams[2] as INamedTypeSymbol;
        var genericTypesInData =new GenericTypesInData
        {
            MatchData = (symbol, symbol.ToDisplayString()),
            TPlayerIndex = (playerIndex, playerIndex.ToDisplayString()),
            TAuthData = (authData, authData.ToDisplayString()),
            TPlayer = (player, player.ToDisplayString()),
        };
        genericTypesInData.Init();
        return genericTypesInData;
    } 
    private static void GenerateCode(SourceProductionContext spc, (Compilation compilation, ImmutableArray<GenericTypesInData?> genericData) data)
    {
        if (data.genericData.Length != 1)
            return;
        var genericTypes = data.genericData[0]!.Value;
    }
    private static void GenerateSocketTransport(SourceProductionContext spc, GenericTypesInData genericTypes)
    {
        spc.AddSource($"{GeneratorUtilities.Realtime.Modules.RealtimeModule}.g.cs", SourceText.From($@"
// <auto-generated>
using System.Net;
using Autofac;
using Realtime.Controllers.Setup.Data;
using Realtime.Controllers.Transporters.Impl;
using Realtime.Controllers.Transporters.Interfaces;
namespace {GeneratorUtilities.Realtime.Modules.ModulesNamespace};
public class {GeneratorUtilities.Realtime.Modules.RealtimeModule} : Module
{{
    private readonly RealtimeConfiguration _configuration;
    public TransportModule(RealtimeConfiguration configuration)
    {{
        _configuration = configuration;
    }}
    protected override void Load(ContainerBuilder moduleBuilder)
    {{
        // Register socket transporter
        moduleBuilder.RegisterType<SocketTransporter<{genericTypes.PlayerGenericArguments}>>()
            .As<ITransporter<{genericTypes.PlayerGenericArguments}>>()
            .SingleInstance().OwnedByLifetimeScope();
        moduleBuilder.RegisterType<MatchContext>()
            .As<IMatchContext<{genericTypes.MatchGenericArguments}>>()
            .AsSelf()
            .SingleInstance();
            
        // Register acceptors
        var max = _configuration.MaxPlayers > 0 ? _configuration.MaxPlayers : int.MaxValue;
        var endpoint = new IPEndPoint(
            IPAddress.Parse(_configuration.Endpoint),
            _configuration.Port
        );
        moduleBuilder.RegisterType<RawSocketConnectionAcceptor>()
            .As<IConnectionAcceptor>()
            .WithParameters(new []
            {{
                TypedParameter.From(endpoint),
                TypedParameter.From(max)
            }})
            .SingleInstance()
            .OwnedByLifetimeScope();
        moduleBuilder.RegisterType<PlayerAcceptor<{genericTypes.PlayerGenericArguments}>>()
            .As<IPlayerAcceptor<{genericTypes.PlayerGenericArguments}>>()
            .SingleInstance();
    }}
}}
"));
    }

    private static void GenerateBehaviours(SourceProductionContext spc, GenericTypesInData genericTypes)
    {
        spc.AddSource($"{GeneratorUtilities.Realtime.Objects.NetworkObject}.g.cs", SourceText.From($@"
// <auto-generated>
namespace {GeneratorUtilities.Realtime.Objects.ObjectsNamespace};
public partial interface {GeneratorUtilities.Realtime.Objects.INetworkBehaviour}
{{
    {GeneratorUtilities.Realtime.Handlers.Impl.MatchContextFullname}? MatchContext {{ get; }}
    {genericTypes.TPlayer.displayName}? Author {{ get; }}
    void AddHandlers(IMatchTickManager<{genericTypes.MatchGenericArguments}> handlerManager);
}}
"));
    }

    private static void GenerateMatchContext(SourceProductionContext spc, GenericTypesInData genericTypes)
    {
        spc.AddSource($"{GeneratorUtilities.Realtime.Handlers.Impl.MatchContext}.g.cs", SourceText.From($@"
// <auto-generated>
namespace {GeneratorUtilities.Realtime.Objects.ObjectsNamespace};
public class {GeneratorUtilities.Realtime.Handlers.Impl.MatchContextFullname} : MatchContext<{genericTypes.MatchGenericArguments}>
{{
}}
"));
    }
    private static void GenerateNetworkObject(SourceProductionContext spc, GenericTypesInData genericTypes)
    {
        spc.AddSource($"{GeneratorUtilities.Realtime.Objects.NetworkObject}.g.cs", SourceText.From($@"
// <auto-generated>
namespace {GeneratorUtilities.Realtime.Objects.ObjectsNamespace};
public sealed partial class {GeneratorUtilities.Realtime.Objects.NetworkObject}
{{
    public {GeneratorUtilities.Realtime.Handlers.Impl.MatchContextFullname} MatchContext {{ get; init; }}
    public {genericTypes.TPlayer.displayName}? Author {{ get; set; }}
    public NetworkObject({GeneratorUtilities.Realtime.Handlers.Impl.MatchContextFullname} context, List<INetworkBehaviour> behaviours, 
        NetworkIndex index, {genericTypes.TPlayerIndex.displayName}? author)
    {{
        MatchContext = context;
        NetworkIndex = index;
        Author = author;
        _behaviours = behaviours;
    }}
    public void Dispose()
    {{
        Scope?.Dispose();
        foreach (var behaviour in _behaviours)
            behaviour.Dispose();
    }}
}}
"));
    }

}