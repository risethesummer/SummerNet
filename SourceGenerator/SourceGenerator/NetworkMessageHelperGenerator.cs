using System.Collections.Immutable;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace SourceGenerator;

[Generator]
public class NetworkMessageHelperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is StructDeclarationSyntax or ClassDeclarationSyntax,
                (ctx, _) => ctx.GetClassOrStructInheritInherit(""))
            .Where(t => t is not null)
            .Collect()
            .Combine(context.CompilationProvider);
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private void GenerateCode(SourceProductionContext spc, (ImmutableArray<INamedTypeSymbol?> Left, Compilation Right) valueTuple)
    {
        spc.AddSource("NetworkMessageHelper.g.cs", SourceText.From($@"
// <auto-generated>
namespace Realtime.Networks
public static class NetworkMessageHelper
{{
    // Generate length depends on opcode
    public static int GetPayloadLength(in ushort id) {{
        
    }}
    public static uint GetPayloadId<TData>() where TData : INetworkPayload {{
        
    }}
}}
", Encoding.UTF8));
    }

    private string BuildPayloadLengthStatements(INamedTypeSymbol symbol, Compilation compilation)
    {
        Marshal.SizeOf()
    }
}